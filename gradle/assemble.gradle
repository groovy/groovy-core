import org.apache.tools.ant.filters.ReplaceTokens
import java.text.SimpleDateFormat

if (!rootProject.useIndy()) {
    apply plugin: 'osgi'
}

group = 'org.codehaus.groovy'
archivesBaseName = 'groovy'

ext.allManifest = manifest {
    attributes("Built-By": System.properties['user.name'],
            "Extension-Name": 'groovy',
            "Specification-Title": 'Groovy: a powerful, dynamic language for the JVM',
            "Specification-Version": project.version,
            "Specification-Vendor": 'The Codehaus',
            "Implementation-Title": 'Groovy: a powerful, dynamic language for the JVM',
            "Implementation-Version": project.version,
            "Implementation-Vendor": 'The Codehaus',
            "Bundle-ManifestVersion": '2',
            "Bundle-Name": 'Groovy Runtime',
            "Bundle-Description": 'Groovy Runtime',
            "Bundle-Version": groovyBundleVersion,
            "Bundle-Vendor": 'The Codehaus',
            "Bundle-ClassPath": '.',
            "Bundle-RequiredExecutionEnvironment": 'J2SE-1.5',
            "Eclipse-BuddyPolicy": 'dependent',
            "Eclipse-LazyStart": 'true',
            "DynamicImport-Package": '*',
            "Main-class": 'groovy.ui.GroovyMain')
}

ext.licenseSpec = copySpec {
    from "$projectDir/config/build"
    from(zipTree(configurations.compile.fileCollection { it.name.startsWith 'commons-cli' }.singleFile).matching {
        include 'META-INF/LICENSE.txt'
    }) {
        eachFile {details ->
            details.path = details.path - 'META-INF'
            details.name = "CLI-LICENSE.txt"
        }
    }
}

task copy(type: Copy) {
    into "$buildDir/meta"
    with licenseSpec
}

def commonOsgiManifest

if (!rootProject.useIndy()) {
    commonOsgiManifest = {
        // We exclude the Bnd-LastModified attribute as it always triggers a rebuild without being really needed.
        from(allManifest) {
            eachEntry {details ->
                if (details.key == 'Bnd-LastModified') {
                    details.exclude()
                }
            }
        }
        version = groovyBundleVersion
        instruction '-nouses', 'true'
        instruction 'Export-Package', "*;version=${version}"
        classpath = sourceSets.main.runtimeClasspath
    }
}

jar {
    dependsOn('dgmConverter')
    metaInf {
        Date buildTime = new Date()
        from "$projectDir/LICENSE.txt"
        from("$projectDir/src/main/META-INF/groovy-release-info.properties") {
            filter {String line ->
                ['##ImplementationVersion##': project.version, '##BundleVersion##': project.groovyBundleVersion,
                        '##BuildDate##': new SimpleDateFormat('dd-MMM-yyyy').format(buildTime),
                        '##BuildTime##': new SimpleDateFormat('hh:mm aa').format(buildTime)].each {key, value ->
                    line = line.replace(key, value)
                }
                line
            }
        }
    }
    if (!rootProject.useIndy()) {
        manifest = osgiManifest {
            symbolicName = 'groovy'
            instruction 'Import-Package', "antlr", "org.objectweb.asm", "*;resolution:=optional"
            classesDir = sourceSets.main.output.classesDir
        }
        manifest commonOsgiManifest
    }
    exclude '**/package-info.class', 'compiler', 'META-INF/groovy-release-info.properties'
}

def modules() {
    subprojects.findAll { it.name =~ /groovy-(?!all-tests)/ }
}

def moduleJars() {
    modules()*.jar.archivePath
}

def mergeModuleDescriptors() {

    new File("$buildDir/tmp/").mkdirs()

    def extensionClasses = []
    def staticExtensionClasses = []

    subprojects.collect {
        new File("${it.buildDir}/classes/main/META-INF/services/org.codehaus.groovy.runtime.ExtensionModule")
    }.findAll { it.exists() }.each {
        def props = new Properties()
        props.load(it.newInputStream())
        extensionClasses += props.get('extensionClasses').split(',').findAll { it }
        staticExtensionClasses += props.get('staticExtensionClasses').split(',').findAll { it }
    }


    def descriptor = new File("$buildDir/tmp/org.codehaus.groovy.runtime.ExtensionModule")
    descriptor.withWriter('UTF-8') {
        it << '# This is a generated file, do not edit\n'
        it << "moduleName=groovy-all\n"
        it << "moduleVersion=${project.version}\n"
        it << "extensionClasses=${extensionClasses.join(',')}\n"
        it << "staticExtensionClasses=${staticExtensionClasses.join(',')}\n"
    }

    descriptor
}

task jarAll(type: Jar, dependsOn: { modules()*.jar }) {
    ext.metaInfDir = "$buildDir/tmp/groovy-all-metainf"
    appendix = 'all'
    if (rootProject.useIndy()) {
        classifier = 'indy'
    }
    doLast {
        manifest.writeTo("$metaInfDir/MANIFEST.MF")
        copy {
            from(mergeModuleDescriptors())
            into "$buildDir/tmp/groovy-all-metainf/services"
        }
        copy {
            into "$buildDir/tmp/groovy-all-metainf"
            with licenseSpec
        }
        project.ant {
            taskdef name: "jarjar", classname: "com.tonicsystems.jarjar.JarJarTask", classpath: configurations.tools.asPath
            jarjar(jarfile: archivePath, manifest: "$metaInfDir/MANIFEST.MF") {
                zipfileset(dir: "$ext.metaInfDir", prefix: 'META-INF')
                zipfileset(src: jar.archivePath)
                moduleJars().each {
                    zipfileset(src: it, excludes: '**/org.codehaus.groovy.runtime.ExtensionModule')
                }
                configurations.runtime.files.findAll {file ->
                    ['antlr', 'asm', 'commons-cli'].any { file.name.startsWith(it) } && ['asm-attr', 'asm-util', 'asm-analysis'].every { !file.name.startsWith(it) }
                }.each {jarjarFile ->
                    zipfileset(src: jarjarFile)
                }
                zipfileset(src: configurations.runtime.files.find { file -> file.name.startsWith('asm-util') },
                    includes: 'org/objectweb/asm/util/AbstractVisitor.class,org/objectweb/asm/util/Trace*')
                rule pattern: "antlr.**", result: "groovyjarjarantlr.@1"
                rule pattern: "org.objectweb.**", result: "groovyjarjarasm.@1"
                rule pattern: "org.apache.commons.cli.**", result: "groovyjarjarcommonscli.@1"
            }
        }
    }
    if (!rootProject.useIndy()) {
        // We exclude the Bnd-LastModified attribute as it always triggers a rebuild without being really needed.
        manifest = osgiManifest {
            symbolicName = 'groovy-all'
            instruction 'Import-Package', "*;resolution:=optional"
            classesDir = jar.archivePath
        }
        manifest commonOsgiManifest
    }
}

allprojects {
    task jarWithIndy(type: GradleBuild) {
        description = 'Triggers an external build generating the indy jar'
        buildFile = 'build.gradle'
        startParameter.projectProperties['indy']=true
        tasks = ['jar']
    }
}


task jarAllWithIndy(type: GradleBuild) {
    description = 'Triggers an external build generating the indy jarAll'
    buildFile = 'build.gradle'
    startParameter.projectProperties['indy']=true
    tasks = ['jarAll']
}

task jarAllAll(dependsOn: [jarAll, jarAllWithIndy]) {
    description = 'Generates groovy-all and groovy-all-indy jars'
    doFirst {
        if (useIndy()) {
            logger.lifecycle('InvokeDynamic support was activated but needs to be off for this pass. Disabling.')
            ext.useIndy = false
        }
    }

}

task sourceAllJar(type: Jar, dependsOn: { modules()*.sourceJar }) {
    with sourceJar.rootSpec
    modules()*.sourceJar.each {
        with it.rootSpec
    }
    appendix = 'all'
    classifier = rootProject.useIndy()?'indy-sources':'sources'
    //with sourceJar.rootSpec
}

task javadocJar(type: Jar, dependsOn: javadoc) {
    classifier = rootProject.useIndy()?'indy-javadoc':'javadoc'
    from javadoc.destinationDir
}

allprojects {
    task groovydocJar(type: Jar, dependsOn: groovydoc) {
        classifier = 'groovydoc'
        from groovydoc.destinationDir
    }
}

task javadocAllJar(type: Jar, dependsOn: javadocAll) {
    appendix = 'all'
    classifier = rootProject.useIndy()?'indy-javadoc':'javadoc'
    from javadocAll.destinationDir
}

task groovydocAllJar(type: Jar, dependsOn: groovydocAll) {
    appendix = 'all'
    classifier = rootProject.useIndy()?'indy-groovydoc':'groovydoc'
    from groovydocAll.destinationDir
}


ext.distSpec = copySpec {
    from("$projectDir") {
        include "LICENSE.txt", "NOTICE.txt"
    }
    into("lib") {
        from configurations.runtime.findAll { it.name.endsWith 'jar' }
        from jar.archivePath
        from modules()*.jar.archivePath
    }

    into("indy") {
        from { new File(jar.archivePath.parent, "${jar.baseName}-${jar.version}-indy.jar") }
        from {
            modules()*.jar.collect { j ->
                new File(j.archivePath.parent, "${j.baseName}-${j.version}-indy.jar")
            }
        }
    }

    into("conf") {
        from "src/conf"
    }
    into("bin") {
        from("src/bin") {
            filter(ReplaceTokens, tokens: [GROOVYJAR:jar.archiveName])
            fileMode = 0755
            ext.exclude = "groovy.icns"
        }
        from("src/bin/groovy.icns")
        from("src/tools/org/codehaus/groovy/tools/groovy.ico")
    }
    into("embeddable") {
        from jarAll.archivePath
        from { new File(jarAll.archivePath.parent, "${jarAll.baseName}-${jarAll.appendix}-${jarAll.version}-indy.jar") }
    }
}

task installGroovy(type: Sync, dependsOn: [jar, jarAll]) {
    from distSpec
    into System.properties.installDirectory ?: "$buildDir/install"
}

//task jars(dependsOn: tasks.withType(Jar))
//task dists(dependsOn: tasks.withType(Zip).matching {task -> !(task instanceof Jar)})

task distBin(type: Zip, dependsOn: [jar, jarAllAll]) {
    appendix = 'binary'
    into("groovy-$version") {
        with distSpec
        with licenseSpec
    }
}

task distDoc(type: Zip, dependsOn: doc) {
    appendix = 'docs'
    into("groovy-$version")
    into("pdf") {
        from 'src/wiki-snapshot.pdf'
    }
    into("html/api") {
        from javadoc.destinationDir
    }
    into("html/gapi") {
        from groovydoc.destinationDir
    }
    into("html/groovy-jdk") {
        from docGDK.destinationDir
    }
}

task distSrc(type: Zip, dependsOn: [javadoc, groovydoc, docGDK]) {
    appendix = 'src'
    into("groovy-$version")
    from(projectDir) {
        exclude 'target', buildDir.path, 'classes/**', 'cruise/**', '.clover/*', 'local.build.properties',
                'cobertura.ser', 'junitvmwatcher*.properties'
    }
}

task dist(dependsOn: [distBin, /*distSrc, distDoc*/]) {
    description = 'Generates the binary, sources and documentation distributions'
}
