= Semantics

This chapter covers the semantic of the Groovy programming language.

== Statements

=== Variable definition

Variables can be defined using either their type (like `String`) or by using the keyword `def`:

[source,groovy]
----
include::{projectdir}/src/spec/test/SemanticsTest.groovy[tags=variable_definition_example,indent=0]
----

`def` is a replacement for a type name. In variable definitions it is used to indicate that you don't care about the type. In variable definitions it is mandatory to either provide a type name explicitly or to use "def" in replacement. This is needed to the make variable definitions detectable for the Groovy parser.

You can think of `def` as an alias of `Object` and you will understand it in an instant.

=== Variable assignment

You can assign values to variables for later use. Try the following:

[source,groovy]
----
include::{projectdir}/src/spec/test/SemanticsTest.groovy[tags=variable_assignment_example,indent=0]
----

==== Multiple assignment

Groovy supports multiple assignment, i.e. where multiple variables can be assigned at once, e.g.:

[source,groovy]
----
include::{projectdir}/src/spec/test/SemanticsTest.groovy[tags=multiple_assignment_example,indent=0]
----

You can provide types as part of the declaration if you wish:

[source,groovy]
----
include::{projectdir}/src/spec/test/SemanticsTest.groovy[tags=multiple_assignment_with_types,indent=0]
----

As well as used when declaring variables it also applies to existing variables:

[source,groovy]
----
include::{projectdir}/src/spec/test/SemanticsTest.groovy[tags=multiple_assignment_with_existing_variables,indent=0]
----

The syntax works for arrays as well as lists, as well as methods that return either of these:

[source,groovy]
----
include::{projectdir}/src/spec/test/SemanticsTest.groovy[tags=multiple_assignment_with_arrays_and_lists,indent=0]
----

==== Overflow and Underflow

If the left hand side has too many variables, excess ones are filled with null's:

[source,groovy]
----
include::{projectdir}/src/spec/test/SemanticsTest.groovy[tags=multiple_assignment_underflow,indent=0]
----

If the right hand side has too many variables, the extra ones are ignored:

[source,groovy]
----
include::{projectdir}/src/spec/test/SemanticsTest.groovy[tags=multiple_assignment_overflow,indent=0]
----

=== Control structures (WIP)
==== Conditional structures
===== if / else

Groovy supports the usual if - else syntax from Java

[source,groovy]
----
include::{projectdir}/src/spec/test/SemanticsTest.groovy[tags=if_else_example,indent=0]
----

Groovy also supports the normal Java "nested" if then else if syntax:

[source,groovy]
----
if ( ... ) {
    ...
} else if (...) {
    ...
} else {
    ...
}
----

===== switch / case

The switch statement in Groovy is backwards compatible with Java code; so you can fall through cases sharing the same code for multiple matches.

One difference though is that the Groovy switch statement can handle any kind of switch value and different kinds of matching can be performed.

[source,groovy]
----
include::{projectdir}/src/spec/test/SemanticsTest.groovy[tags=switch_case_example,indent=0]
----

Switch supports the following kinds of comparisons:

* Class case values matches if the switch value is an instance of the class
* Regular expression case value matches if the string of the switch value matches the regex
* Collection case value matches if the switch value is contained in the collection. This also includes ranges (since they are Lists)
* If none of the above are used then the case value matches if the case value equals the switch value

NOTE: +default+ must go at the end of the switch/case. While in Java the default can be placed anywhere in the switch/case, the default in Groovy is used more as an else than assigning a default case.

==== Looping structures
===== Classic for loop

Groovy supports the standard Java / C for loop:

[source,groovy]
----
include::{projectdir}/src/spec/test/SemanticsTest.groovy[tags=classic_for_loop_example,indent=0]
----

===== for in loop

The for loop in Groovy is much simpler and works with any kind of array, collection, Map, etc.

[source,groovy]
----
include::{projectdir}/src/spec/test/SemanticsTest.groovy[tags=groovy_for_loop_example,indent=0]
----

===== while loop

Groovy supports the usual while {...} loops like Java:

[source,groovy]
----
include::{projectdir}/src/spec/test/SemanticsTest.groovy[tags=while_loop_example,indent=0]
----

==== Exception handling

Exception handling is the same as Java.

==== try / catch / finally

You can specify a complete +try-catch-finally+, a +try-catch+, or a +try-finally+ set of blocks.

NOTE: Braces are required around each block's body.

[source,groovy]
----
include::{projectdir}/src/spec/test/SemanticsTest.groovy[tags=try_catch_example,indent=0]
----

We can put code within a 'finally' clause following a matching 'try' clause, so that regardless of whether the code in the 'try' clause throws an exception, the code in the finally clause will always execute:

[source,groovy]
----
include::{projectdir}/src/spec/test/SemanticsTest.groovy[tags=try_catch_finally_example,indent=0]
----

==== Multi-catch

With the multi catch block (since Groovy 2.0), we're able to define several exceptions to be catch and treated by the same catch block:

[source,groovy]
----
try {
    /* ... */
} catch ( IOException | NullPointerException e ) {
    /* one block to handle 2 exceptions */
}
----

=== Power assertion (TBD)
=== Labeled statements (TBD)

== Expressions (TBD)

=== GPath expressions (TBD)

== Promotion and coercion (TBD)

=== Number promotion (TBD)
=== Closure to type coercion
==== Assigning a closure to a SAM type
A SAM type is a type which defines a single abstract method. This includes:

[source,groovy]
.Functional interfaces
----
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=filter_sam_type,indent=0]
----

[source,groovy]
.Abstract classes with single abstract method
----
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=greeter_sam_type,indent=0]
----

Any closure can be converted into a SAM type using the `as` operator:

[source,groovy]
----
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=assertions_explicit_closure_to_sam,indent=0]
----

However, the `as Type` expression is optional since Groovy 2.2.0. You can omit it and simply write:

[source,groovy]
----
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=assertions_implicit_closure_to_sam,indent=0]
----

which means you are also allowed to use method pointers, as shown in the following example:

[source,groovy]
----
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=assertions_implicit_closure_to_sam_and_method_pointer,indent=0]
----

==== Calling a method accepting a SAM type with a closure

The second and probably more important use case for closure to SAM type coercion is calling a method which accepts
a SAM type. Imagine the following method:

[source,groovy]
-----
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=method_accepting_filter,indent=0]
-----

Then you can call it with a closure, without having to create an explicit implementation of the interface:

[source,groovy]
-----
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=method_call_with_explicit_coercion,indent=0]
-----

But since Groovy 2.2.0, you are also able to omit the explicit coercion and call the method as if it used a closure:

[source,groovy]
-----
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=method_call_with_implicit_coercion,indent=0]
-----

As you can see, this has the advantage of letting you use the closure syntax for method calls, that is to say put the
closure outside of the parenthesis, improving the readability of your code.

==== Closure to arbitrary type coercion

In addition to SAM types, a closure can be coerced to any type and in particular interfaces. Let's define the
following interface:

[source,groovy]
----
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=foobar_interface,indent=0]
----

You can coerce a closure into the interface using the `as` keyword:

[source,groovy]
----
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=foobar2closure_coercion,indent=0]
----

This produces a class for which all methods are implemented using the closure:

[source,groovy]
----
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=foobarintf_assertions,indent=0]
----

But it is also possible to coerce a closure to any class. For example, we can replace the `interface` that we defined
with `class` without changing the assertions:

[source,groovy]
----
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=closure2foobarclass,indent=0]
----

=== Map to type coercion

Usually using a single closure to implement an interface or a class with multiple methods is not the way to go. As an
alternative, Groovy allows you to coerce a map into an interface or a class. In that case, keys of the map are
interpreted as method names, while the values are the method implementation. The following example illustrates the
coercion of a map into an `Iterator`:

[source,groovy]
----
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=coerce_map_to_iterator,indent=0]
----

Of course this is a rather contrived example, but illustrates the concept. You only need to implement those methods
that are actually called, but if a method is called that doesn't exist in the map a `MissingMethodException` or an
`UnsupportedOperationException` is thrown, depending on the arguments passed to the call,
as in the following example:

[source,groovy]
----
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=define_x_interface,indent=0]
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=call_existing_method,indent=0]
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=call_non_existing_method,indent=0]
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=call_notimplemented_method,indent=0]
----

The type of the exception depends on the call itself:

* `MissingMethodException` if the arguments of the call do not match those from the interface/class
* `UnsupportedOperationException` if the arguments of the call match one of the overloaded methods of the interface/class

=== String to enum coercion

Groovy allows transparent +String+ (or +GString+) to enum values coercion. Imagine you define the following enum:

[source,groovy]
----
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=state_enum,indent=0]
----

then you can assign a string to the enum without having to use an explicit `as` coercion:

[source,groovy]
----
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=enum_coerce_assignment,indent=0]
----

It is also possible to use a +GString+ as the value:

[source,groovy]
----
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=enum_coerce_assignment_gstring,indent=0]
----


However, this would throw a runtime error (+IllegalArgumentException+):
[source,groovy]
----
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=enum_coerce_assignment_wrong,indent=0]
----

Note that it is also possible to use implicit coercion in switch statements:

[source,groovy]
----
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=enum_switch_method,indent=0]
----

in particular, see how the `case` use string constants. But if you call a method that uses an enum with a +String+
argument, you still have to use an explicit `as` coercion:

[source,groovy]
----
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=enum_switch_test,indent=0]
----

=== Custom type coercion

It is possible for a class to define custom coercion strategies by implementing the +asType+ method. Custom coercion
is invoked using the `as` operator and is never implicit. As an example,
imagine you defined two classes, +Polar+ and +Cartesian+, like in the following example:

[source,groovy]
----
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=polar_class_header,indent=0]
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=polar_class_footer,indent=0]
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=cartesian_class,indent=0]
----

And that you want to convert from polar coordinates to cartesian coordinates. One way of doing this is to define
the +asType+ method in the +Polar+ class:

[source,groovy]
----
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=polar_class_astype,indent=0]
----

which allows you to use the +as+ coercion operator:

[source,groovy]
----
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=polar_astype_assert,indent=0]
----

Putting it all together, the +Polar+ class looks like this:
[source,groovy]
----
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=polar_class_header,indent=0]
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=polar_class_astype,indent=4]
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=polar_class_footer,indent=0]
----

but it is also possible to define +asType+ outside of the +Polar+ class, which can be practical if you want to define
custom coercion strategies for "closed" classes or classes for which you don't own the source code, for example using
a metaclass:

[source,groovy]
----
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=polar_metaclass_astype,indent=0]
----

=== Class literals vs variables and the as operator

Using the `as` keyword is only possible if you have a static reference to a class, like in the following code:

[source,groovy]
----
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=as_keyword,indent=0]
----

But what if you get the class by reflection, for example by calling `Class.forName`?

[source,groovy]
----
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=clazz_greeter_header,indent=0]
----

Trying to use the reference to the class with the `as` keyword would fail:

[source,groovy]
----
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=incorrect_as_usage,indent=0]
----

It is failing because the `as` keyword only works with class literals. Instead, you need to call the `asType` method:

[source,groovy]
----
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=fixed_as_usage,indent=0]
----

== Optionality (TBD)

=== Optional parentheses (TBD)
=== Optional semicolons (TBD)
=== Optional return keyword (TBD)
=== Optional public keyword (TBD)

[[Groovy-Truth]]
== The Groovy Truth (TBD)

=== Customizing the truth with asBoolean() methods (TBD)

== Typing (TBD)

=== Optional typing (TBD)
=== Static type checking (TBD)
=== Static compilation (TBD)

